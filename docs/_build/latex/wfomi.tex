%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{wfomi}
\date{May 30, 2020}
\release{0.1}
\author{korecki}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{index:introduction}}
This is the documentation for the wfomi solver written in python3.
Wfomi stands for weighted first orde model integration.
The solver implements a novel algorithm based on the work of Jonathan Feldstein.
The solver outperforms the wfomc solver \sphinxhyphen{} Forclift as well as wmi solver \sphinxhyphen{} pywmi in terms of efficiency and expressiveness.

To run the solver, change directory to the solver folder and call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python3 pywfomi.py [circuit1\PYGZus{}filename] [circuit2\PYGZus{}filename] [weight\PYGZus{}filename]}
\end{sphinxVerbatim}

without the brackets and with the intended filenames

\begin{DUlineblock}{0em}
\item[] circuit 1 represents the partition circuit so the one containing the entire theory
\item[] circuit 2 represents the query circuit
\item[] weights represent the simple and complex weights corresponding to predicates appearing the circuits of interest
\end{DUlineblock}

Example call would look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python3 pywfomi.py test\PYGZus{}input/smokers/theory.txt test\PYGZus{}input/smokers/query.txt test\PYGZus{}input/smokers/weights\PYGZus{}simple.txt}
\end{sphinxVerbatim}

The docs folder contains this documentation.
The test\_input folder contains examples that can be run to test the software.


\chapter{Input files}
\label{\detokenize{index:input-files}}
The solver requires two kinds of input files.
The two files representing the circuits, the theory circuit and the query circuit and the one file representing the weights of the predicates occuring in the two cicuits. In this section we present the syntax of these files. The default parser included in the solver works with the here explained file formats, however it should be easy to extend or introduce new parsers for different file formats.


\section{Weights file}
\label{\detokenize{index:weights-file}}
The weights file contains the weights corresponding to the predicates included in the circuit files.
In the weights file there can be 3 types of lines:
| the domain line eg. ‘person = \{Alice\}’
| the simple weight line eg. ‘pre: {[}1, 1{]} const{[}1, 10{]}’, meaning the predicate pre is assigned weight 1*1 and its negation is assigned weight 1*10
| the complex weight line eg. ‘bmi(x)fun x**2 + 10 bounds{[}5, 10{]} const{[}1, 10{]}’
Note that for complex weights the negation weight has to be specified seperately eg. ‘neg bmi(x)fun x**2 + 10 bounds{[}10, 20{]}’.
The name of the arguments of the weight functions must correspond to the argument names used in the circuit description.
The const{[}1, 5{]} indicates the constant multiplier on the weight function and if omitted defaults to 1. This is used for computational speed up.

An example of the weights file follows. Additional examples can be found in test\_input folder.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+go}{person = \PYGZob{}Guy, Nima, Wannes, Jesse, Luc\PYGZcb{}}
\PYG{g+go}{friends: [0.1, 0.9]}
\PYG{g+go}{smokes(b)fun \PYGZhy{}0.001*(b\PYGZhy{}27)**2+0.3  bounds[35, 45] }
\PYG{g+go}{neg smokes(b)fun \PYGZhy{}0.001*(b\PYGZhy{}27)**2+0.3  bounds[10, 35] }
\PYG{g+go}{f\PYGZus{}1: [7.38905609893065, 1]}
\end{sphinxVerbatim}


\section{Cicuit file}
\label{\detokenize{index:cicuit-file}}
The circuit files contain the theory and query circuits.
There are two types of lines in the circuit file, one corresponding to the contents of the given node and the other indicating the connections between nodes. These lines can be intermixed but for readibility it is customary to first write the contents lines and then the connections lines.
The lines always begin with the nX eg. n1 where X indicates the unique node number which is used to identify it.

The contens lines are then followed by the description of the node. This can be a connective ‘and’, ‘or’, a leaf including the given predicate eg. ‘smokes(x)’, a quantifier eg. A\{x\}\{persons\} or a constant C\{x\}\{persons\}. The quantifier and constant lines are of the form Z\{x\}\{persons\}, where Z can be A or E indicating a universal or existentiar quantifiers. The first braces store the variable(s) that is quantified over and the second braces store the domain of the variable. If the node quantifies over more than one variable they are listed seperated by commas and so are the domains like: C\{x, y\}\{persons, animals\}. Moreover if the domain of the quantifier is constrained not to include a given object we denote it by E\{x\}\{persons/Alice\} where persons normally include Alice. Futhermore the type of the domain can be included, eg. if a given quantifier is a descendant of an existential quantifier it must refer to one of the splits of the original domain induced by the existential. Those splits are reffered to as top and bot and are indicated like: A\{x\}\{persons\sphinxhyphen{}bot\}

The connections lines are of the form nX \sphinxhyphen{}\textgreater{} xY, eg. n0 \sphinxhyphen{}\textgreater{} n1 indicating n1 is the child of n0.

An example of the circuit file follows. Additional examples can be found in test\_input folder.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+go}{  n23 and}
\PYG{g+go}{  n0  C\PYGZob{}X\PYGZcb{}\PYGZob{}person\PYGZcb{} friends(X,X) or neg friends(X,X) }
\PYG{g+go}{  n22 E\PYGZob{}x\PYGZcb{}\PYGZob{}person\PYGZcb{}}
\PYG{g+go}{  n21 and}
\PYG{g+go}{  n1  C\PYGZob{}X,Y\PYGZcb{}\PYGZob{}person\PYGZhy{}bot/Y, person\PYGZhy{}bot\PYGZcb{} friends(X,Y) or neg friends(X,Y) }
\PYG{g+go}{  n20 and}
\PYG{g+go}{  n2  C\PYGZob{}X,Y\PYGZcb{}\PYGZob{}person/Y, person\PYGZhy{}top\PYGZcb{} friends(X,Y) or neg friends(X,Y) }
\PYG{g+go}{  n19 and}
\PYG{g+go}{  n3  C\PYGZob{}X\PYGZcb{}\PYGZob{}person\PYGZhy{}top\PYGZcb{} smokes(X) }
\PYG{g+go}{  n18 and}
\PYG{g+go}{  n4  C\PYGZob{}X,Y\PYGZcb{}\PYGZob{}person, person\PYGZhy{}top\PYGZcb{} f\PYGZus{}1(X,Y) }
\PYG{g+go}{  n17 and}
\PYG{g+go}{  n5  C\PYGZob{}X\PYGZcb{}\PYGZob{}person\PYGZhy{}bot\PYGZcb{} neg smokes(X) }
\PYG{g+go}{  n16 and}
\PYG{g+go}{  n6  C\PYGZob{}X,Y\PYGZcb{}\PYGZob{}person\PYGZhy{}bot, person\PYGZhy{}bot\PYGZcb{} f\PYGZus{}1(X,Y) }
\PYG{g+go}{  n15 A\PYGZob{}x\PYGZcb{}\PYGZob{}person\PYGZhy{}top\PYGZcb{}}
\PYG{g+go}{  n14 A\PYGZob{}y\PYGZcb{}\PYGZob{}person\PYGZhy{}bot\PYGZcb{}}
\PYG{g+go}{  n13 or}
\PYG{g+go}{  n9 and}
\PYG{g+go}{  n7  f\PYGZus{}1(x,y)}
\PYG{g+go}{  n8  neg friends(x,y)}
\PYG{g+go}{  n12 and}
\PYG{g+go}{  n10  neg f\PYGZus{}1(x,y)}
\PYG{g+go}{  n11  friends(x,y)}
\PYG{g+go}{  n23 \PYGZhy{}\PYGZgt{} n0;}
\PYG{g+go}{  n23 \PYGZhy{}\PYGZgt{} n22;}
\PYG{g+go}{  n22 \PYGZhy{}\PYGZgt{} n21;}
\PYG{g+go}{  n21 \PYGZhy{}\PYGZgt{} n1;}
\PYG{g+go}{  n21 \PYGZhy{}\PYGZgt{} n20;}
\PYG{g+go}{  n20 \PYGZhy{}\PYGZgt{} n2;}
\PYG{g+go}{  n20 \PYGZhy{}\PYGZgt{} n19;}
\PYG{g+go}{  n19 \PYGZhy{}\PYGZgt{} n3;}
\PYG{g+go}{  n19 \PYGZhy{}\PYGZgt{} n18;}
\PYG{g+go}{  n18 \PYGZhy{}\PYGZgt{} n4;}
\PYG{g+go}{  n18 \PYGZhy{}\PYGZgt{} n17;}
\PYG{g+go}{  n17 \PYGZhy{}\PYGZgt{} n5;}
\PYG{g+go}{  n17 \PYGZhy{}\PYGZgt{} n16;}
\PYG{g+go}{  n16 \PYGZhy{}\PYGZgt{} n6;}
\PYG{g+go}{  n16 \PYGZhy{}\PYGZgt{} n15;}
\PYG{g+go}{  n15 \PYGZhy{}\PYGZgt{} n14;}
\PYG{g+go}{  n14 \PYGZhy{}\PYGZgt{} n13;}
\PYG{g+go}{  n13 \PYGZhy{}\PYGZgt{} n9;}
\PYG{g+go}{  n13 \PYGZhy{}\PYGZgt{} n12;}
\PYG{g+go}{  n9 \PYGZhy{}\PYGZgt{} n7;}
\PYG{g+go}{  n9 \PYGZhy{}\PYGZgt{} n8;}
\PYG{g+go}{  n12 \PYGZhy{}\PYGZgt{} n10;}
\PYG{g+go}{  n12 \PYGZhy{}\PYGZgt{} n11;}
\end{sphinxVerbatim}


\chapter{Code}
\label{\detokenize{index:code}}
Here follows the documentation of the python code of the solver.


\section{wfomi}
\label{\detokenize{index:module-wfomi}}\label{\detokenize{index:wfomi}}\index{module@\spxentry{module}!wfomi@\spxentry{wfomi}}\index{wfomi@\spxentry{wfomi}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-0}}\index{module@\spxentry{module}!wfomi@\spxentry{wfomi}}\index{wfomi@\spxentry{wfomi}!module@\spxentry{module}}\index{wfomi() (in module wfomi)@\spxentry{wfomi()}\spxextra{in module wfomi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:wfomi.wfomi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{wfomi.}}\sphinxbfcode{\sphinxupquote{wfomi}}}{\emph{\DUrole{n}{partitionFile}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{queryFile}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{weightFile}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
the main function of the solver, takes the theory circuit, query circuit and the weight files 
as arguments from the command line in that order and returns the probability of the query 
or as arguments if called as a function from a different module
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{partitionFile}} \textendash{} the path to the file contiaining the theory circuit which will be used to compute the partition function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{queryFile}} \textendash{} the path to the file containing the query circuit which will be used to compute unnormalised probability of the query

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weightFile}} \textendash{} the path to the weight file containing the weights of the predicates in the theory and query circuits

\end{itemize}

\item[{Returns}] \leavevmode
the probability of the query. In addition the time to compute is printed along with the partition function and unnormalised query

\end{description}\end{quote}

\end{fulllineitems}



\section{term}
\label{\detokenize{index:module-term}}\label{\detokenize{index:term}}\index{module@\spxentry{module}!term@\spxentry{term}}\index{term@\spxentry{term}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-1}}\index{module@\spxentry{module}!term@\spxentry{term}}\index{term@\spxentry{term}!module@\spxentry{module}}\index{Term (class in term)@\spxentry{Term}\spxextra{class in term}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{term.}}\sphinxbfcode{\sphinxupquote{Term}}}{\emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{const}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
The Term object represent the smallest computational unit over the circuit representation. The Term is used to store the weight
functions in symbolic form, the associated bounds and the constant multiplier. The term implements multiplication and addition as well
as integration. The weights, bounds and constants are all lists and their elements corresponding to elements of a sum.
\index{\_\_add\_\_() (term.Term method)@\spxentry{\_\_add\_\_()}\spxextra{term.Term method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term.__add__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_add\_\_}}}{\emph{\DUrole{n}{other}}}{}
Implements addition for two terms.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} the right hand side {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} of addition

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} representing the sum of two terms

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (term.Term method)@\spxentry{\_\_init\_\_()}\spxextra{term.Term method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{const}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
initialises the term object with specified weights, bounds and constant multiplier
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} the weight function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} \textendash{} the bounds of the weight function containing the integrated variable, the lower and upper bounds in that order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{const}} \textendash{} the constant multiplier

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_mul\_\_() (term.Term method)@\spxentry{\_\_mul\_\_()}\spxextra{term.Term method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term.__mul__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_mul\_\_}}}{\emph{\DUrole{n}{other}}}{}
Implements multiplication for two terms taking care of bounds of functions of the same variables.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} the right hand side {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} of multiplication

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} representing the multiplied terms

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_str\_\_() (term.Term method)@\spxentry{\_\_str\_\_()}\spxextra{term.Term method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
prints the term

\end{fulllineitems}

\index{integrate() (term.Term method)@\spxentry{integrate()}\spxextra{term.Term method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.Term.integrate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate}}}{}{}
Implements efficient integation of a term.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} with constant multiplier 1, empty bounds and the numerical value of the integrated constituent terms summed

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{integrateFromDict() (in module term)@\spxentry{integrateFromDict()}\spxextra{in module term}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.integrateFromDict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{term.}}\sphinxbfcode{\sphinxupquote{integrateFromDict}}}{\emph{\DUrole{n}{weight}}, \emph{\DUrole{n}{bounds}}}{}
helper function for the integration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} \textendash{} the weight function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} \textendash{} the bounds of the weight function

\end{itemize}

\item[{Retuns}] \leavevmode
the numeric value of the integrated weight function

\end{description}\end{quote}

\end{fulllineitems}

\index{symbolicToNumeric() (in module term)@\spxentry{symbolicToNumeric()}\spxextra{in module term}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:term.symbolicToNumeric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{term.}}\sphinxbfcode{\sphinxupquote{symbolicToNumeric}}}{\emph{\DUrole{n}{weight}}, \emph{\DUrole{n}{bounds}}}{}
helper function for the integration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} \textendash{} the weight function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} \textendash{} the bounds of the weight function

\end{itemize}

\item[{Retuns}] \leavevmode
the numeric value of the integal within the given bounds

\end{description}\end{quote}

\end{fulllineitems}



\section{circuit}
\label{\detokenize{index:module-circuit}}\label{\detokenize{index:circuit}}\index{module@\spxentry{module}!circuit@\spxentry{circuit}}\index{circuit@\spxentry{circuit}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-2}}\index{module@\spxentry{module}!circuit@\spxentry{circuit}}\index{circuit@\spxentry{circuit}!module@\spxentry{module}}
each node has a compute class which follows the computation step of the algorithm for the given node
the maxDomainSize is used to compute the maximum domain size for the existential node
.. moduleauthor:: Marcin Korecki
\index{AndNode (class in circuit)@\spxentry{AndNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.AndNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{AndNode}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.AndNode method)@\spxentry{compute()}\spxextra{circuit.AndNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.AndNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the and node by multiplying two terms at its child nodes. the domSize and removed are passed for 
potential existential and universals that may be the node’s descendants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domSize}} \textendash{} the size of the domain of the ancestor quantifiers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{removed}} \textendash{} the list of objects removed from the domain

\end{itemize}

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} representing the multiplication of the values at the child nodes of the or node

\end{description}\end{quote}

\end{fulllineitems}

\index{maxDomainSize() (circuit.AndNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.AndNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.AndNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node, the maxDomain is the larger domain out of the domains of the
left and right children
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the maximum size of the domain at the given node and the set of objects removed from it

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ConstNode (class in circuit)@\spxentry{ConstNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{ConstNode}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nodeName}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{varList}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{\_\_init\_\_() (circuit.ConstNode method)@\spxentry{\_\_init\_\_()}\spxextra{circuit.ConstNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nodeName}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{varList}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
initialises the constant node with the
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} represents the type of a constant node (and, or, leaf)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodeName}} \textendash{} used as a key in a dictionary storing the domains of the nodes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{varList}} \textendash{} the list of variables the constant node deals with

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domData}} \textendash{} the dictionary containing the data on the domains corresponding to variables, the data stores 3 values for

\end{itemize}

\end{description}\end{quote}

each variable, the list of objects in the domain, the domain type (top or bot depending on the existential split) and the without set 
representing the objects removed from the domain

\end{fulllineitems}

\index{compute() (circuit.ConstNode method)@\spxentry{compute()}\spxextra{circuit.ConstNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Computes the symbolic value at the constant node depending on its type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domSize}} \textendash{} the size of the domain of the ancestor quantifiers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{removed}} \textendash{} the list of objects removed from the domain

\end{itemize}

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} representing the value at the constant node which is eithe symbolic if the node is under a universal

\end{description}\end{quote}

node quantifying over the same domain or otherwise numeric corresponding to universal quantification over its domain

\end{fulllineitems}

\index{maxDomainSize() (circuit.ConstNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.ConstNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ConstNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node based on the largest domain of the variables of the constant node
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the maximum size of the domain at the given node and the set of objects removed from it

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExistsNode (class in circuit)@\spxentry{ExistsNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{ExistsNode}}}{\emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{\_\_init\_\_() (circuit.ExistsNode method)@\spxentry{\_\_init\_\_()}\spxextra{circuit.ExistsNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
initialises the existential node with the variables it quantifies over and the data on the corresponding domains{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} the name of the variable that the universal quantifies over

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domData}} \textendash{} the dictionary containing the data on the domains corresponding to variables, the data stores 3 values for

\end{itemize}

\end{description}\end{quote}

each variable, the list of objects in the domain, the domain type (top or bot depending on the existential split) and the without set 
representing the objects removed from the domain

\end{fulllineitems}

\index{compute() (circuit.ExistsNode method)@\spxentry{compute()}\spxextra{circuit.ExistsNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the existential node based on the size of the domain it quantifies over and taking into account the
objects removed from it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domSize}} \textendash{} the size of the domain the existential is quantifying over

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{removed}} \textendash{} the list of objects removed from the domain

\end{itemize}

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} representing the value at the existential node

\end{description}\end{quote}

\end{fulllineitems}

\index{maxDomainSize() (circuit.ExistsNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.ExistsNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ExistsNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the maximum size of the domain at the given node and the set of objects removed from it

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ForAllNode (class in circuit)@\spxentry{ForAllNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{ForAllNode}}}{\emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{\_\_init\_\_() (circuit.ForAllNode method)@\spxentry{\_\_init\_\_()}\spxextra{circuit.ForAllNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{domData}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\begin{description}
\item[{initialises the universal node with the variables it quantifies over and the data on the domain that }] \leavevmode
the variables correspond to

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} the name of the variable that the universal quantifies over

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domData}} \textendash{} the dictionary containing the data on the domains corresponding to variables, the data stores 3 values for

\end{itemize}

\end{description}\end{quote}

each variable, the list of objects in the domain, the domain type (top or bot depending on the existential split) and the without set 
representing the objects removed from the domain

\end{fulllineitems}

\index{compute() (circuit.ForAllNode method)@\spxentry{compute()}\spxextra{circuit.ForAllNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the numerical value at the universal node based on the size of the domain it quantifies over taking into account the 
objects that have been removed from it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domSize}} \textendash{} the size of the domain the universal is quantifying over

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{removed}} \textendash{} the list of objects removed from the domain

\end{itemize}

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} with a cosntant equal to 1, empty bounds and the result of the integration at the universal node

\end{description}\end{quote}

raised to the power of its domain size

\end{fulllineitems}

\index{maxDomainSize() (circuit.ForAllNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.ForAllNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.ForAllNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the maximum size of the domain at the given node and the set of objects removed from it

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LeafNode (class in circuit)@\spxentry{LeafNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{LeafNode}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{\_\_init\_\_() (circuit.LeafNode method)@\spxentry{\_\_init\_\_()}\spxextra{circuit.LeafNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
initialises the leaf node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} the key for the dictionary containing the weights

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} a dictionary containing all the data pertaining to the weights of a predicate. In case of simple weights it is a

\end{itemize}

\end{description}\end{quote}

single value. In case of complex weights it is the symbolic weight function, the bounds, the arguments of the function and the
constant multiplier in that order

\end{fulllineitems}

\index{compute() (circuit.LeafNode method)@\spxentry{compute()}\spxextra{circuit.LeafNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the leaves depending on weather the corresponding weight is a float or a function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domSize}} \textendash{} the size of the domain of the ancestor quantifiers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{removed}} \textendash{} the list of objects removed from the domain

\end{itemize}

\item[{Retuns}] \leavevmode
the term corresponding to the weight function of the predicate at the node

\end{description}\end{quote}

\end{fulllineitems}

\index{maxDomainSize() (circuit.LeafNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.LeafNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.LeafNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 as the domain of the leaf node is empty as it does not quantify over anything

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Node (class in circuit)@\spxentry{Node}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.Node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{Node}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
The base class defining a node, all other nodes inherit from it
\index{\_\_init\_\_() (circuit.Node method)@\spxentry{\_\_init\_\_()}\spxextra{circuit.Node method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.Node.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\index{maxDomainSize() (circuit.Node method)@\spxentry{maxDomainSize()}\spxextra{circuit.Node method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.Node.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node

\end{fulllineitems}


\end{fulllineitems}

\index{OrNode (class in circuit)@\spxentry{OrNode}\spxextra{class in circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.OrNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{circuit.}}\sphinxbfcode{\sphinxupquote{OrNode}}}{\emph{\DUrole{n}{left}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{right}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{compute() (circuit.OrNode method)@\spxentry{compute()}\spxextra{circuit.OrNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.OrNode.compute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute}}}{\emph{\DUrole{n}{domSize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{removed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
computes the symbolic value at the or node by adding two terms at its child nodes, the setsize and removed are passed for potential 
existential and universals that may be the node’s descendants
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domSize}} \textendash{} the size of the domain of the ancestor quantifiers

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{removed}} \textendash{} the list of objects removed from the domain

\end{itemize}

\item[{Returns}] \leavevmode
the {\hyperref[\detokenize{index:term.Term}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Term}}}}} representing the sum of the values at the child nodes of the or node

\end{description}\end{quote}

\end{fulllineitems}

\index{maxDomainSize() (circuit.OrNode method)@\spxentry{maxDomainSize()}\spxextra{circuit.OrNode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:circuit.OrNode.maxDomainSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxDomainSize}}}{}{}
used to compute the maximum domain size for the existential node, the maxDomain is the larger domain out of the domains of the
left and right children
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the maximum size of the domain at the given node and the set of objects removed from it

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{parser}
\label{\detokenize{index:module-parser}}\label{\detokenize{index:parser}}\index{module@\spxentry{module}!parser@\spxentry{parser}}\index{parser@\spxentry{parser}!module@\spxentry{module}}\phantomsection\label{\detokenize{index:module-3}}\index{module@\spxentry{module}!parser@\spxentry{parser}}\index{parser@\spxentry{parser}!module@\spxentry{module}}\index{Parser (class in parser)@\spxentry{Parser}\spxextra{class in parser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parser.}}\sphinxbfcode{\sphinxupquote{Parser}}}
the parser for the default circuit and weight files defined by the author. The files descriptions can be found in the docs
\index{\_\_init\_\_() (parser.Parser method)@\spxentry{\_\_init\_\_()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
the parsers stores 3 regex patterns used to detect lines containing node data, which is split into node number and node data, 
and link data. It also stores the forward and backward connections as well as the created nodes as dictionaries

\end{fulllineitems}

\index{adjustConstNodes() (parser.Parser method)@\spxentry{adjustConstNodes()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.adjustConstNodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adjustConstNodes}}}{\emph{\DUrole{n}{constCorrection}}}{}
adjusts the circuit by moving the constant nodes down when they are above a univesal quantifier over the same domain,
adjusts the moved nodes to not integrate on themselves during wfomi computation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{constCorrection}} \textendash{} the list storing the constant nodes for possible adjustment by {\hyperref[\detokenize{index:parser.Parser.adjustConstNodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{adjustConstNodes()}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{ancestorIsForAll() (parser.Parser method)@\spxentry{ancestorIsForAll()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.ancestorIsForAll}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ancestorIsForAll}}}{\emph{\DUrole{n}{node}}}{}
a helper function used in adjustConstNodes to check if the node has a universal quantifier as an ancestor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} the name of the node for which we want to check if one of its ancestors is a universal quantifier

\item[{Returns}] \leavevmode
None if there are no universal ancestors or the first universal ancestor node object

\end{description}\end{quote}

\end{fulllineitems}

\index{connectNodes() (parser.Parser method)@\spxentry{connectNodes()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.connectNodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connectNodes}}}{}{}
connects the nodes in self.nodes dictionary based on data in self.connections

\end{fulllineitems}

\index{nextMatchingForAll() (parser.Parser method)@\spxentry{nextMatchingForAll()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.nextMatchingForAll}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nextMatchingForAll}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{domain}}}{}
a helper function used in adjustConstNodes to detect the next universal quantifier of a given node with matching domain
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} the name of the node for which we want to check if one of its ancestors is a universal quantifier

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domain}} \textendash{} the domain of the node

\end{itemize}

\item[{Returns}] \leavevmode
None if there are no matching universal quantifier or the matchin node name

\end{description}\end{quote}

\end{fulllineitems}

\index{parseCircuit() (parser.Parser method)@\spxentry{parseCircuit()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseCircuit}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{weights}}, \emph{\DUrole{n}{domains}}}{}
parses a circuit file with the given name and creates nodes using data on the weight functions and domains
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} the path to the circuit file to be parsed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} the weights dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domains}} \textendash{} the domains dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\end{itemize}

\item[{Returns}] \leavevmode
the root node and the dictionary of all nodes

\end{description}\end{quote}

\end{fulllineitems}

\index{parseConnections() (parser.Parser method)@\spxentry{parseConnections()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseConnections}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseConnections}}}{\emph{\DUrole{n}{content}}}{}
parses the link lines of a circuit file with the given name and stores the connections between nodes in self.connections, 
and self.reverseConnections
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{content}} \textendash{} the contents of the file as read by {\hyperref[\detokenize{index:parser.Parser.parseCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseCircuit()}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{parseConst() (parser.Parser method)@\spxentry{parseConst()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseConst}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseConst}}}{\emph{\DUrole{n}{line}}, \emph{\DUrole{n}{constCorrection}}, \emph{\DUrole{n}{weights}}, \emph{\DUrole{n}{domains}}, \emph{\DUrole{n}{node}}}{}
parses a line contianing a constant node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{line}} \textendash{} the contents of the line containing the quantifier as read by {\hyperref[\detokenize{index:parser.Parser.parseCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseCircuit()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{constCorrection}} \textendash{} the list storing the constant nodes for possible adjustment by {\hyperref[\detokenize{index:parser.Parser.adjustConstNodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{adjustConstNodes()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} the weights dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domains}} \textendash{} the domains dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} the constant node name

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{parseNodes() (parser.Parser method)@\spxentry{parseNodes()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseNodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseNodes}}}{\emph{\DUrole{n}{content}}, \emph{\DUrole{n}{constCorrection}}, \emph{\DUrole{n}{weights}}, \emph{\DUrole{n}{domains}}}{}
parses the node lines of a circuit file with the given name, creates and stores the nodes in the nodes dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{content}} \textendash{} the contents of the file as read by {\hyperref[\detokenize{index:parser.Parser.parseCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseCircuit()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{constCorrection}} \textendash{} the list storing the constant nodes for possible adjustment by {\hyperref[\detokenize{index:parser.Parser.adjustConstNodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{adjustConstNodes()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} \textendash{} the weights dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domains}} \textendash{} the domains dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{parseQuantifier() (parser.Parser method)@\spxentry{parseQuantifier()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseQuantifier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseQuantifier}}}{\emph{\DUrole{n}{line}}, \emph{\DUrole{n}{domains}}}{}
parses a line contianing a universal or existential quantifier
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{line}} \textendash{} the contents of the line containing the quantifier as read by {\hyperref[\detokenize{index:parser.Parser.parseCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseCircuit()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domains}} \textendash{} the domains dictionary as returned by the {\hyperref[\detokenize{index:parser.Parser.parseWeights}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parseWeights()}}}}}

\end{itemize}

\item[{Returns}] \leavevmode
objects contained in the domain and the corresponding variable name

\end{description}\end{quote}

\end{fulllineitems}

\index{parseWeights() (parser.Parser method)@\spxentry{parseWeights()}\spxextra{parser.Parser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:parser.Parser.parseWeights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseWeights}}}{\emph{\DUrole{n}{name}}}{}
parses the weight file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} the path to the weight file to be parsed

\item[{Retuns}] \leavevmode
dictionaries containing the weights and domains of all the predicates

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{circuit}\sphinxstyleindexpageref{index:\detokenize{module-2}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{parser}\sphinxstyleindexpageref{index:\detokenize{module-3}}
\indexspace
\bigletter{t}
\item\relax\sphinxstyleindexentry{term}\sphinxstyleindexpageref{index:\detokenize{module-1}}
\indexspace
\bigletter{w}
\item\relax\sphinxstyleindexentry{wfomi}\sphinxstyleindexpageref{index:\detokenize{module-0}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}